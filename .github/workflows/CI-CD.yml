name: FreeStyle Final Project CI-CD

# Controls when the workflow will run
on:
  #push:
    #branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'Prod'
        type: choice
        options:
          - Prod
          
env:
  AWS_REGION: "eu-west-1"
  ECR_REPOSITORY: "freestyle"
  APP_NAME: "freestyle-api"
  EKS_CLUSTER_NAME: "Freestyle"
  EKS_NAMESPACE: ${{ secrets.EKS_NAMESPACE || 'freestyle' }}
  #SPLUNK_URL: ${{ secrets.SPLUNK_URL }}
  #SPLUNK_TOKEN: ${{ secrets.SPLUNK_TOKEN }}
  #SPLUNK_INDEX: ${{ secrets.SPLUNK_INDEX }}
  #ENVIRONMENT: splunk

permissions:
  id-token: write
  contents: read

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    name: ðŸŽ¯ Build Image on runner

    outputs:
      image_tag: ${{ steps.generate-tag.outputs.UNIQUE_TAG }}
      ecr_registry: ${{ steps.login-ecr.outputs.registry }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      - name: Checkout repository ðŸ“‚
        uses: actions/checkout@v3

      - name: Configure AWS credentials ðŸ”
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::017923816312:role/GithubActionsAvivLevyDeployRole
          #role-session-name: GitHub_to_AWS_via_FederatedOIDC

      - name: Login to Amazon ECR ðŸ”‘
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Create .env file from secrets
        run: |
          echo "ðŸ”§ Creating environment file..."
          echo "${{ secrets.ENV }}" > .env
          echo "âœ… Environment file created successfully!"

      - name: Generate Tag
        id: generate-tag
        run: |
          BUILD_NUMBER=${{ github.run_number }}
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          echo "UNIQUE_TAG="${{env.APP_NAME}}"-${BUILD_NUMBER}-${TIMESTAMP}" >> $GITHUB_OUTPUT

      - name: Build and push Docker image ðŸ—ï¸
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          UNIQUE_TAG: ${{ steps.generate-tag.outputs.UNIQUE_TAG }}
        run: |
          echo "ðŸ”¨ Starting Docker build..."
          echo "ðŸ” Build triggered by: ${{ github.event_name }}"
          
          # Build Docker image
          docker build \
            --build-arg ENVIRONMENT=$ENVIRONMENT \
            -t $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$UNIQUE_TAG \
            .

          # Push to ECR
          echo "â¬†ï¸ Pushing image to ECR..."
          docker push $ECR_REGISTRY/${{ env.ECR_REPOSITORY }}:$UNIQUE_TAG
          
          if [ $? -eq 0 ]; then
            echo "âœ… Image pushed successfully with tag: $UNIQUE_TAG"
          fi

# Deploy image to eks
  Deploy-to-eks:
    runs-on: ubuntu-latest
    name: ðŸŽ¯ Deploy image to eks
    needs: build-and-push

    steps:
      - name: Configure AWS credentials ðŸ”
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: arn:aws:iam::017923816312:role/GithubActionsAvivLevyDeployRole 

      - name: Setup kubectl & auth to EKS ðŸ§©
        run: |
            aws eks update-kubeconfig \
              --name "$EKS_CLUSTER_NAME" \
              --region "$AWS_REGION"
            kubectl version --client=true


      - name: Ensure namespace exists ðŸ§±
        run: |
          kubectl get ns "$EKS_NAMESPACE" >/dev/null 2>&1 || kubectl create ns "$EKS_NAMESPACE"

# Deployment file configuration
      - name: Render Kubernetes manifests ðŸ“„
        env:
         IMAGE: ${{ needs.build-and-push.outputs.ecr_registry }}/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-push.outputs.image_tag }}
        run: |
            cat > k8s.yaml <<EOF
            apiVersion: apps/v1
            kind: Deployment
            metadata:
              name: ${APP_NAME}
              namespace: ${EKS_NAMESPACE}
              labels:
                app: ${APP_NAME}
            spec:
              replicas: 2
              selector:
                matchLabels:
                  app: ${APP_NAME}
              template:
                metadata:
                  labels:
                    app: ${APP_NAME}
                spec:
                  containers:
                    - name: ${APP_NAME}
                      image: ${IMAGE}
                      imagePullPolicy: IfNotPresent
                      ports:
                        - containerPort: 8080
                      envFrom:
                        - secretRef:
                            name: ${APP_NAME}-env
                      resources:
                        requests:
                          cpu: "100m"
                          memory: "128Mi"
                        limits:
                          cpu: "500m"
                          memory: "512Mi"
                  # If your nodes need ECR creds, EKS + IRSA handles this automatically.
            # ---
            # apiVersion: v1
            # kind: Service
            # metadata:
            #   name: ${APP_NAME}
            #   namespace: ${EKS_NAMESPACE}
            #   labels:
            #     app: ${APP_NAME}
            # spec:
            #   type: LoadBalancer   # change to ClusterIP/NodePort if desired
            #   selector:
            #     app: ${APP_NAME}
            #   ports:
            #     - name: http
            #       port: 80
            #       targetPort: 8080
            EOF
  


# apply the deploy
      - name: Apply manifests ðŸš€
        run: |
          kubectl apply -f k8s.yaml


      - name: Wait for rollout â±ï¸
        run: |
          kubectl rollout status deploy/${APP_NAME} -n ${EKS_NAMESPACE} --timeout=300s
          echo ""
          echo "Deployed image:"
          echo "  $ECR_REGISTRY/${ECR_REPOSITORY}:${IMAGE_TAG}"          


      - name: Show service endpoint ðŸŒ
        run: |
          kubectl get svc ${APP_NAME} -n ${EKS_NAMESPACE} -o wide
